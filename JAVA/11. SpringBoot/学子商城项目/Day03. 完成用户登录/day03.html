<!DOCTYPE html>
<html>
<head>
<title>day03</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h3>9. 用户-登录-业务层</h3>
<p><strong>(a) 规划异常</strong></p>
<p>&quot;用户名不存在&quot;,&quot;密码错误&quot;,&quot;数据被标记为已删除&quot;，因此应该创建一下异常类：</p>
<pre><code>cn.tedu.store.service.ex.UserNotFoundException

cn.tedu.store.service.ex.PasswordNotMatchException
</code></pre>

<p>查询操作，从本质上来讲，查不到不算异常，不会单独设计一个<code>SelectException</code></p>
<p><strong>(b) 接口和抽象方法</strong></p>
<p>在<code>IUserService</code>下添加一个新的抽象方法：</p>
<pre><code>User login(String username,String password) throws UserNotFoundException, PasswordNotMatchException;
</code></pre>

<p><strong>(c) 实现接口</strong></p>
<p>在<code>UserServiceImpl</code>中添加对以上方法的实现：</p>
<pre><code>public User login(String username,String password) throws UserNotFoundException, PasswordNotMatchException{
    // 获取User中的username
    // 调用持久层的findByUsername(username) -&gt; User
    // 判断User是否为null
    // 是：抛出 UserNotFoundException

    // 获取user中的isDelete
    // 判断isDelete是否为1
    // 是：抛出 UserNotFoundException

    // 获取查询到的盐值
    // 对用户传入的密码进行加密
    // 获取查询到的密码
    // 判断两个密码是否不一致
    // 是：抛出 PasswordNotMatchException

    // 将盐值设为null
    // 将密码设为null
    // 将isDelete设为null
    // 返回user 
}
</code></pre>

<p>在<code>src/test/java</code>的<code>cn.tedu.store.service.UserServiceTests</code>中开发测试方法，测试登录效果，具体代码如下：</p>
<pre><code>@Test
public void login() {
    try {
        String username=&quot;root&quot;;
        String password=&quot;1234x&quot;;
        User user=service.login(username, password);
        System.err.println(user);
    } catch (Exception e) {
        System.err.println(e.getClass().getName());
        System.err.println(e.getMessage());
    }
}
</code></pre>

<h3>10. 用户-登录-控制器层</h3>
<p><strong>(a) 统一异常处理</strong></p>
<p>在<code>cn.tedu.store.controller.BaseController</code>中添加对<code>UserNotFoundException</code>和<code>PasswordNotMatchException</code>的处理。</p>
<pre><code>@ExceptionHandler(ServiceException.class)
@ResponseBody
public JsonResult&lt;Void&gt; handlerException(Throwable e){
    // 根据不同异常的类型提供不同的处理方式
    // 现在的处理方式是根据不同的类型，返回不同的状态码
    JsonResult&lt;Void&gt; jr=new JsonResult&lt;&gt;();

    if(e instanceof UsernameDuplicateException) {
        jr.setState(ERROR_USERNAME_DUPLICATE);
        jr.setMessage(e.getMessage());
    }else if(e instanceof UserNotFoundException) {
        jr.setState(31);
        jr.setMessage(e.getMessage());
    }else if(e instanceof PasswordNotMatchFoundException) {
        jr.setState(32);
        jr.setMessage(e.getMessage());
    }else if(e instanceof InsertException) {
        jr.setState(40);
        jr.setMessage(e.getMessage());
    }

    return jr;
}
</code></pre>

<p><strong>(b) 设计请求</strong></p>
<p>设计“用户登录”的请求方式：</p>
<pre><code>请求路径：/users/login
请求参数：String username,String password, HttpSession session
请求方式：POST
响应数据：JsonResult&lt;User&gt;
</code></pre>

<p><strong>(c) 实现请求</strong></p>
<p>在<code>cn.tedu.store.controller.UserController</code>中添加<code>login</code>方法，处理用户的登录请求：</p>
<pre><code>@RequestMapping(&quot;login&quot;)
public JsonResult&lt;User&gt; login(
    String username,String password, HttpSession session){

    // 调用service的login()进行登录
    User user=service.login(username,password);

    // 向session中添加uid
    session.setAttribute(&quot;uid&quot;,user.getUid());

    // 向session中添加username
    session.setAttribute(&quot;username&quot;,user.getUsername());

    JsonResult&lt;User&gt; jr=new JsonResult();
    jr.setData(user);
    jr.setState(SUCCESS);

    return jr;
}
</code></pre>

<p>在浏览器使用<code>http://localhost:8080/users/login?username=root&amp;password=1234</code>进行测试。</p>
<p>测试通过后，将方法前的<code>@RequestMapping</code>改为<code>@PostMapping</code></p>
<h3>11. 用户-登录-前端界面</h3>
<p>注意，需要将“登录”按钮的类型从&quot;submit&quot;改为&quot;button&quot;</p>
<h3>12. 用户-修改密码-持久层</h3>
<p><strong>(a) 规划SQL语句</strong></p>
<p>“修改密码”是一个更新操作，大致的语句应该是：</p>
<pre><code>update 
    t_user
set 
    password=?,
    modified_user=?, 
    modified_time=? 
where 
    uid=?
</code></pre>

<p>在修改之前，应该先验证用户输入的“原密码”是否正确，但是不应该是这样：</p>
<pre><code>update t_user set password=? where uid=? and password=?
</code></pre>

<p>应该尽量不在SQL语句中去验证密码：</p>
<pre><code>1. mysql数据库大小写不敏感，而密码是敏感的，验证可能存在问题
2. 需要“在修改密码前验证原密码”属于业务层的需求，应该优先考虑在业务层来实现
</code></pre>

<p>需要提供一个根据uid查询用户密码的方法：</p>
<pre><code>select password, salt, is_delete from t_user where uid=?;
</code></pre>

<p><strong>(b) 接口和抽象方法</strong></p>
<p>在<code>cn.tedu.store.mapper.UserMapper</code>接口中添加以下2个抽象方法：</p>
<pre><code>User findByUid(Integer uid);

Integer updatePassword(
    @Param(&quot;uid&quot;) Integer uid,
    @Param(&quot;password&quot;) String password,
    @Param(&quot;modifiedUser&quot;) String modifiedUser,
    @Param(&quot;modifiedTime&quot;) Date modifiedTime);
</code></pre>

<p><strong>(c) 配置映射</strong></p>
<p>可以在<code>UserMapper.xml</code>中的根节点下配置<code>&lt;resultMapp&gt;</code>节点，指定数据库表的<strong>列名(column)</strong>和实体类的<strong>属性名(property)</strong>的对应关系：</p>
<pre><code>&lt;resultMap id=&quot;UserEntityMap&quot; 
    type=&quot;cn.tedu.store.entity.User&quot; &gt;
    &lt;id column=&quot;uid&quot; property=&quot;uid&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; /&gt;
    &lt;result column=&quot;salt&quot; property=&quot;salt&quot; /&gt;
    &lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; /&gt;
    &lt;result column=&quot;phone&quot; property=&quot;phone&quot; /&gt;
    &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;  
    &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt;    
    &lt;result column=&quot;avatar&quot; property=&quot;avatar&quot; /&gt;    
    &lt;result column=&quot;created_user&quot; property=&quot;createdUser&quot; /&gt; 
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; /&gt; 
    &lt;result column=&quot;modified_user&quot; property=&quot;modifiedUser&quot; /&gt;   
    &lt;result column=&quot;modified_time&quot; property=&quot;modifiedTime&quot; /&gt;   
&lt;/resultMap&gt;
</code></pre>

<p>并在对应的<code>&lt;select&gt;</code>节点使用<code>resultMap</code>属性替代<code>resultType</code>属性，则在SQL语句中无需再使用<strong>as</strong>来指定别名。</p>
<p>在<code>java/main/resources</code>下的<code>mappers</code>中的<code>UserMapper.xml</code>中添加以上2个抽象方法的映射：</p>
<pre><code>&lt;!-- 根据uid查用户信息 --&gt;
&lt;!-- User findByUid(Integer uid) --&gt;
&lt;select id=&quot;findByUid&quot; 
    resultType=&quot;cn.tedu.store.entity.User&quot;&gt;
    select 
        password, salt,
        is_delete
    from 
        t_user 
    where 
        uid=#{uid};
&lt;/select&gt;

&lt;!-- 更新密码 --&gt;
&lt;!-- Integer updatePassword(
    @Param(&quot;uid&quot;) Integer uid,
    @Param(&quot;password&quot;) String password,
    @Param(&quot;modifiedUser&quot;) String modifiedUser,
    @Param(&quot;modifiedTime&quot;) Date modifiedTime)  --&gt;
&lt;update id=&quot;updatePassword&quot;&gt;
    update 
        t_user
    set 
        password=#{password},
        modified_user=#{modifiedUser}, 
        modified_time=#{modifiedTime} 
    where 
        uid=#{uid}
&lt;/update&gt;
</code></pre>

<p>在<code>src/test/java</code>中的<code>cn.tedu.store.mapper.UserMapperTests</code>中开发测试方法，测试以上2个方法：</p>
<pre><code>@Test
public void findByUid() {
    User user=mapper.findByUid(11);
    System.err.println(user);
}

@Test
public void updatePassword() {
    Integer uid=9;
    String password=&quot;6789&quot;;
    String modifiedUser=&quot;炒鸡管理员&quot;;
    Date modifiedTime=new Date();
    Integer row=mapper.updatePassword(
            uid, password, modifiedUser, modifiedTime);
    System.err.println(&quot;row=&quot;+row);
}
</code></pre>

<p>注意：这里的测试会对用户数据造成破坏，因此可以新注册一个用户来测试，不要对<strong>root</strong>用户进行测试。</p>
<h3>13. 用户-修改密码-业务层</h3>
<p><strong>(a) 规划异常</strong></p>
<p>更新操作，应该有一个异常来代表那些原因不好描述的更新异常<code>cn.tedu.store.service.ex.UpdateException</code></p>
<p>在验证原始密码是否正确之前，应该验证该数据是否有效，is_delete不为1，如果为1，可以使用<code>UserNotFoundException</code></p>
<p>原始密码错误，则不能更新新密码，可以使用<code>PasswordNotMatchException</code></p>
<p><strong>(b) 接口和抽象方法</strong></p>
<p>在<code>IUserService</code>中添加以下抽象方法：</p>
<pre><code>void changePassword (
    Integer uid,
    String oldPassword,
    String newPassword,
    String modifiedUser)
        throws  
            UserNotFoundException, PasswordNotMatchException, UpdateException;
</code></pre>

<p><strong>(c) 实现接口</strong></p>
<p>在<code>UserServiceImpl</code>中实现上面的抽象方法</p>
<pre><code>public void changePassword (Integer uid,
    String oldPassword, String newPassword,
    String modifiedUser)throws  
            UserNotFoundException, PasswordNotMatchException, UpdateException{
    // 使用uid查询用户数据
    // 判断返回结果是否为null
    // 是：UserNotFoundException

    // 判断isDelete是否为1
    // 是：UserNotFoundException

    // 获取查询到的盐值
    // 对旧密码进行加密
    // 比较加密结果和查询到的用户密码是否不一致
    // 是：PasswordNotMatchException

    // 对新密码进行加密
    // 调用updatePassword()更新密码
    // 判断受影响的行数是否不为1
    // 是：UpdateException

}
</code></pre>

<p>实现代码如下：</p>
<pre><code>@Override
public void changePassword(Integer uid, String oldPassword, String newPassword, String modifiedUser)
        throws UserNotFoundException, PasswordNotMatchException, UpdateException {
    // 使用uid查询用户数据
    User user=mapper.findByUid(uid);
    // 判断返回结果是否为null
    if(user ==null) {
        // 是：UserNotFoundException
        throw new UserNotFoundException(&quot;修改密码异常！用户数据不存在&quot;);
    }

    // 判断isDelete是否为1
    if(user.getIsDelete().equals(1)) {
        // 是：UserNotFoundException
        throw new UserNotFoundException(&quot;修改密码异常！用户数据不存在&quot;);  
    }

    // 获取查询到的盐值
    String salt=user.getSalt();
    // 对旧密码进行加密
    String oldMd5Password=getMd5Password(oldPassword, salt);
    // 比较加密结果和查询到的用户密码是否不一致
    if(!oldMd5Password.equals(user.getPassword())) {
        // 是：PasswordNotMatchException
        throw new PasswordNotMatchException(&quot;修改密码异常！原始密码错误&quot;);
    }

    // 对新密码进行加密
    String newMd5Password=getMd5Password(newPassword, salt);
    // 调用updatePassword()更新密码
    Integer row=mapper.updatePassword(uid, newMd5Password, modifiedUser, new Date());
    // 判断受影响的行数是否不为1
    if(!row.equals(1)) {
        // 是：UpdateException
        throw new UpdateException(&quot;修改密码异常！请联系管理员&quot;);
    }

}
</code></pre>

<p>在<code>src/test/java</code>的<code>cn.tedu.store.service.UserServiceTests</code>中开发测试方法，测试修改密码的效果，具体代码如下：</p>
<pre><code>@Test
public void changePassword() {
    try {
        Integer uid=16;
        String oldPassword=&quot;1234&quot;;
        String newPassword=&quot;5678&quot;;
        String modifiedUser=&quot;管理员&quot;;
        service.changePassword(uid, oldPassword, newPassword, modifiedUser);
    }catch (Exception e) {
        System.err.println(e.getClass().getName());
        System.err.println(e.getMessage());
    }
}
</code></pre>

<p>刚刚的异常使用Maven的UpdateProject后自动解决</p>
<p>代码和笔记已上传，15分钟实现修改密码的业务层代码并测试</p>
<p>16：15回来继续写后面的内容</p>
<h3>14. 用户-修改密码-控制器层</h3>
<p><strong>(a) 统一异常处理</strong></p>
<p>在<code>cn.tedu.store.controller.BaseController</code>中添加对<code>UpdateException</code>的处理。</p>
<pre><code>@ExceptionHandler(ServiceException.class)
@ResponseBody
public JsonResult&lt;Void&gt; handlerException(Throwable e){
    // 根据不同异常的类型提供不同的处理方式
    // 现在的处理方式是根据不同的类型，返回不同的状态码
    JsonResult&lt;Void&gt; jr=new JsonResult&lt;&gt;(e.getMessage());

    if(e instanceof UsernameDuplicateException) {
        jr.setState(ERROR_USERNAME_DUPLICATE);
    }else if(e instanceof UserNotFoundException) {
        jr.setState(31);
    }else if(e instanceof PasswordNotMatchFoundException) {
        jr.setState(32);
    }else if(e instanceof InsertException) {
        jr.setState(40);
    }else if(e instanceof UpdateException) {
        jr.setState(41);
    }

    return jr;
}
</code></pre>

<p><strong>(b) 设计请求</strong></p>
<p>设计“修改密码”的请求方式</p>
<pre><code>请求路径：/users/change_password
请求参数：@RequestParam(&quot;old_password&quot;) String oldPassword, @RequestParam(&quot;new_password&quot;) String newPassword,HttpSession session
请求方式：POST
响应数据：JsonResult&lt;Void&gt;
</code></pre>

<p><strong>(c) 实现请求</strong></p>
<p>在<code>cn.tedu.store.controller.UserController</code>中添加对应的方法<code>changePassword()</code>来处理修改密码的请求：</p>
<pre><code>@RequestMapping(&quot;change_password&quot;)
public JsonResult&lt;Void&gt; changePassword(@RequestParam(&quot;old_password&quot;) String oldPassword, @RequestParam(&quot;new_password&quot;) String newPassword,HttpSession session){

    // 从session中获取uid
    Integer uid=Integer.valueOf(session.getAttribute(&quot;uid&quot;).toString());

    // 从session中获取username
    String username=session.getAttribute(&quot;username&quot;).toString();

    service.changePassword(uid,oldPassword,newPassword,username);
    return new JsonResult&lt;Void&gt;(SUCCESS);
}
</code></pre>

<p>测试之前，必须先登录<strong>root</strong>用户</p>
<p>完成后，可以在浏览器上使用<code>localhost:8080/users/change_password?old_password=1234&amp;new_password=5678</code>;</p>
<p>“修改密码”是用户登录之后才能执行的操作，在修改之前，应该检查用户的登录状态。</p>
<p>可以使用过滤器或拦截器实现相关功能。</p>
<p>在这里使用拦截器<code>cn.tedu.store.interceptor.LoginInterceptor</code>，封装的是拦截请求后执行的逻辑：</p>
<pre><code>@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {
    HttpSession session=request.getSession();

    if(session.getAttribute(&quot;uid&quot;)==null) {
        // 重定向到登录页面
        response.sendRedirect(&quot;http://localhost:8080/web/login.html&quot;);
        return false;
    }

    // 放行
    return true;
}
</code></pre>

<p>为了让拦截器生效，需要开发一个拦截器的配置类<code>cn.tedu.store.config.InterceptorConfigurer</code>，应该实现<code>WebMvcConfigurer</code>,重写<code>addInterceptors</code>，在其中注册我们自己开发的拦截器：</p>
<pre><code>@Override
public void addInterceptors(InterceptorRegistry registry) {
    HandlerInterceptor loginInterceptor=new LoginInterceptor();

    InterceptorRegistration ir=registry.addInterceptor(loginInterceptor);
    // 黑名单
    ir.addPathPatterns(&quot;/**&quot;);

    // 不拦 注册/登录 静态资源
    List&lt;String&gt; patterns=new ArrayList&lt;String&gt;();
    // 静态资源
    patterns.add(&quot;/bootstrap3/**&quot;);
    patterns.add(&quot;/css/**&quot;);
    patterns.add(&quot;/images/**&quot;);
    patterns.add(&quot;/js/**&quot;);
    // 注册和登录页面
    patterns.add(&quot;/web/login.html&quot;);
    patterns.add(&quot;/web/register.html&quot;);
    // 注册和登录控制器
    patterns.add(&quot;/users/login&quot;);
    patterns.add(&quot;/users/reg&quot;);

    // 白名单
    ir.excludePathPatterns(patterns);

}
</code></pre>

<p>该配置类如果想要生效，必须在类前添加<code>@Configuration</code></p>
<p>拦截器生效后，用户未登录时，请求<code>/web/password.html</code>，会被自动重定向到登录页面</p>
<h3>15. 用户-修改密码-前端界面</h3>
<h3>-----------------------------</h3>
<p>每个功能实现的步骤：</p>
<h3>1. 创建数据表</h3>
<h3>2. 创建实体类</h3>
<h3>3. 用户-XXX-持久层</h3>
<p><strong>(a) 规划SQL语句</strong></p>
<p><strong>(b) 接口和抽象方法</strong></p>
<p><strong>(c) 配置映射</strong></p>
<h3>2. 用户-XXX-业务层</h3>
<p><strong>(a) 规划异常</strong></p>
<p><strong>(b) 接口和抽象方法</strong></p>
<p><strong>(c) 实现接口</strong></p>
<h3>3. 用户-XXX-控制器层</h3>
<p><strong>(a) 统一异常处理</strong></p>
<p><strong>(b) 设计请求</strong></p>
<p><strong>(c) 实现请求</strong></p>
<h3>4. 用户-XXX-前端界面</h3>
<h3>Spring返回的JSON数据处理</h3>
<ol>
<li>在Spring默认生成的JSON数据中，有一些值为null的属性，我们希望它不要添加到JSON字符串中</li>
<li>
<p>解决方案：使用 @JsonInclude</p>
<ol>
<li>
<p>添加在类前</p>
<ol>
<li>@JsonInclude(value=Include.ALWAYS)代表将该类中所有的属性添加到JSON中，不论其值是否为NULL</li>
<li>@JsonInclude(value=Include.NON_NULL)代表如果一个属性的值为NULL，在生成的JSON字符串中不添加该属性</li>
</ol>
</li>
<li>
<p>添加在属性前</p>
<ol>
<li>可以对属性进行更精准的控制</li>
<li>如果该属性的值为NULL，并设置为NON_NULL，那么不会被添加到JONS中</li>
</ol>
</li>
<li>
<p>可以在application.properties中添加一行配置：<code>spring.jackson.default-property-inclusion=NON_NULL</code>，默认采用NON_NULL的策略</p>
</li>
</ol>
</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
