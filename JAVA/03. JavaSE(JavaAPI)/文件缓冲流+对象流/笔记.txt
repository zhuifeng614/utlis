缓冲输出流的缓冲区问题:
	void flush()
	强制将当前缓冲流中已缓存的字节一次性写出。
	频繁的调用flush会提高实际写出数据的频率，
	这会降低写出效率，但是会提高写出数据即时性。
	根据需求而定
	.close();
	缓冲流在close时会自动flush一次。


使用缓冲流加快读写效率完成文件复制操作。
	缓冲字节流:
		java.io.BufferedInputStream
		java.io.BufferedOutputStream
		缓冲流的功能为加快读写效率，无论我们操作流时的读写
		是单字节读写还是块读写，缓冲流最终都会转换为块读写
		来保证读写效率，从而起到加快读写效率的目的。
		
缓冲流内部有一个字节数组作为缓冲区，当我们
	使用缓冲输入流读取一字节(d = bis.read())时
	实际上缓冲流会一次性读取一组字节并存入自己内
	部的字节数组中(块读)，然后将第一个字节返回，
	如果我们再次调用读取一字节方法时，缓冲流直接
	将字节数组中第二个字节返回，直到所有字节均返
	回后，才会再次实际读取一组字节回来。
	因此，缓冲输入流就是将实际读取操作转换为块读
	取操作来保证的读取效率。
	缓冲输出流也是一样的道理。



JAVA IO  java标准的输入与输出

java将IO流按照读写功能分为输入流与输出流
java.io.InputStream:所有字节输入流的超类，规定了
输入流读取字节的相关操作。

java.io.OutputStream:所有字节输出流的超类,规定了
输出流写出字节的相关操作。

java IO流以标准的方式对外界设备进行读写，通过创建
不同的节点流来与特定数据源进行数据交互。

java将流分为两大类:节点流与处理流
节点流:又称为低级流，是实际连接程序与数据源的"管道"
用于实际搬运数据的流，读写一定是建立在低级流的基础上
进行的。

处理流:又称为高级流，高级流不能独立存在，必须连接在
其他流上，目的是当数据"流经"当前流时可以对其进行某种
加工处理，简化我们读写数据时的操作。
串联一组高级流最终连接到低级流上，在读写的过程中以
流水线式的加工处理完成读写操作称为"流的连接"，这也是
java IO的精髓所在(学习重点)


文件流
文件流是一对低级流，用于读写文件的流。其功能与RAF
一致。但是底层实际的读写方式不同。
RandomAccessFile是以指针形式对文件进行随机读写的，
并且RAF既可以读数据也可以写数据，能做到对文件部分
数据的修改操作。

文件流是以标准IO形式读写数据的，而标准IO是以顺序
读写形式进行操作的(只能向后读或写，不能回退。)

所以在读写的灵活性上文件流不如RAF，但是由于文件流
是以标准IO形式读写，可以利用强大的流连接将一个复杂
的数据读写操作简单化，这是RAF做不到的。


使用当前类实例测试对象流的对象读写操作

希望被对象流序列化的类必须实现接口:
java.io.Serializable

Serializable接口中没有任何抽象方法，但是该接口是
编译器敏感的，当编译器在编译一个类的源代码时若发现
其实现了可序列化接口，那么会在编译class文件时包含
一个方法，这个方法的功能是将这个类的实例转换为一组
字节。对象流就是用这个方法将该对象转换为字节的。
但是由于源代码中不需要体现，因此我们实现可序列化接口
时不需要重写任何方法。

对象输入流，用于读取一个java对象
需要注意，读取的这组字节必须是通过对象输出流将
一个对象转换的一组字节，否则读取过程会抛出异常。
对象输入流将一组字节按照其描述结构还原该对象
的过程称为:对象的反序列化

对象流是一对高级流，使用它们可以方便的在对象与字节
之间进行转换，方便我们读写任何java对象。
将给定对象按照其结构转换为一组字节并通过
		对象流连接的流将这组对象写出
		
		将对象通过对象流写入文件这里经历两个过程
		1:当对象经过对象输出流时，对象输出流将
		  这个对象按照其结构转换为了一组字节，这组
		  字节包括了该对象的结构信息和实际数据。
		  这个过程称为"对象序列化"
		  
		2:序列化后的这组字节再经过文件流后就被写入
		  了文件中，写入文件就等于写入了磁盘做长久
		  保存，而将数据写入磁盘的过程称为"数据持久化"
